"""
Training Script for Steganalysis Detection System

This script trains the steganalysis models to detect hidden text in images
generated by the GAN-based steganography system.
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, List, Dict
import os
import sys
from tqdm import tqdm
import json

# Add src directory to path
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

from steganalysis_system import SteganalysisSystem, BinaryTextDetector, CapacityEstimator, TextTypeClassifier
from text_gan_architecture import TextSteganoGenerator, TextExtractor
from text_processor import TextProcessor


class SteganalysisTrainer:
    """Trainer for steganalysis detection models."""
    
    def __init__(self, device: str = 'cpu'):
        self.device = device
        
        # Initialize steganalysis system
        self.steganalysis = SteganalysisSystem(device)
        
        # Initialize steganography system for generating training data
        self.setup_steganography_system()
        
        # Training history
        self.training_history = {
            'detector_loss': [],
            'capacity_loss': [],
            'type_loss': [],
            'detector_accuracy': [],
            'capacity_mae': [],
            'type_accuracy': []
        }
    
    def setup_steganography_system(self):
        """Setup the steganography system for generating training data."""
        try:
            # Initialize components
            self.text_processor = TextProcessor()
            self.generator = TextSteganoGenerator().to(self.device)
            self.extractor = TextExtractor().to(self.device)
            
            # Try to load pre-trained weights
            model_path = os.path.join('models', 'best_stego_model.pth')
            if os.path.exists(model_path):
                checkpoint = torch.load(model_path, map_location=self.device)
                if 'generator' in checkpoint:
                    self.generator.load_state_dict(checkpoint['generator'])
                if 'extractor' in checkpoint:
                    self.extractor.load_state_dict(checkpoint['extractor'])
                print("✅ Loaded pre-trained steganography models")
            else:
                print("⚠️ No pre-trained steganography models found, using random weights")
                
        except Exception as e:
            print(f"⚠️ Error setting up steganography system: {e}")
            self.generator = None
            self.extractor = None
    
    def generate_training_data(self, num_samples: int = 2000) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, List[str]]:
        """Generate training data using the steganography system."""
        
        print(f"Generating {num_samples} training samples...")
        
        all_images = []
        detection_labels = []  # Binary: has text or not
        capacity_labels = []   # Text length
        type_labels = []       # 0: plain, 1: encrypted, 2: unknown
        text_samples = []
        
        # Generate positive samples (images with hidden text)
        positive_samples = num_samples // 2
        
        for i in tqdm(range(positive_samples), desc="Generating positive samples"):
            # Create random text
            text_length = np.random.randint(5, 50)
            
            # Determine text type
            text_type = np.random.choice(['plain', 'encrypted'])
            
            if text_type == 'plain':
                # Generate English-like text
                words = ['hello', 'world', 'secret', 'message', 'hidden', 'text', 'the', 'and', 'for', 'are']
                text = ' '.join(np.random.choice(words, np.random.randint(2, 8)))
                text = text[:text_length] if len(text) > text_length else text
                type_label = 0
            else:
                # Generate encrypted-like text (random characters)
                import string
                text = ''.join(np.random.choice(list(string.ascii_letters + string.digits), text_length))
                type_label = 1
            
            # Create cover image (random CIFAR-10 like image)
            cover_image = torch.randn(1, 3, 32, 32).to(self.device)
            
            # Generate steganographic image
            if self.generator is not None:
                try:
                    # Encode text
                    text_tokens = self.text_processor.encode_text(text)
                    text_embedding = self.text_processor.tokens_to_embedding(text_tokens).to(self.device)
                    
                    # Generate stego image
                    with torch.no_grad():
                        stego_image = self.generator(cover_image, text_embedding)
                    
                    all_images.append(stego_image.squeeze(0).cpu())
                except Exception as e:
                    print(f"Error generating stego image: {e}")
                    # Fallback to cover image with slight modification
                    noise = torch.randn_like(cover_image) * 0.01
                    all_images.append((cover_image + noise).squeeze(0).cpu())
            else:
                # Fallback: add slight noise to simulate steganographic modifications
                noise = torch.randn_like(cover_image) * 0.01
                all_images.append((cover_image + noise).squeeze(0).cpu())
            
            detection_labels.append(1)  # Has hidden text
            capacity_labels.append(len(text))
            type_labels.append(type_label)
            text_samples.append(text)
        
        # Generate negative samples (clean images)
        negative_samples = num_samples - positive_samples
        
        for i in tqdm(range(negative_samples), desc="Generating negative samples"):
            # Clean image
            clean_image = torch.randn(3, 32, 32)
            
            all_images.append(clean_image)
            detection_labels.append(0)  # No hidden text
            capacity_labels.append(0)
            type_labels.append(2)  # Unknown/no text
            text_samples.append("")
        
        # Convert to tensors
        images = torch.stack(all_images)
        detection_labels = torch.tensor(detection_labels, dtype=torch.float32)
        capacity_labels = torch.tensor(capacity_labels, dtype=torch.float32)
        type_labels = torch.tensor(type_labels, dtype=torch.long)
        
        print(f"✅ Generated {len(images)} training samples")
        return images, detection_labels, capacity_labels, type_labels, text_samples
    
    def train_binary_detector(self, train_loader: DataLoader, epochs: int = 20) -> List[float]:
        """Train the binary text detector."""
        
        print("Training Binary Text Detector...")
        
        optimizer = optim.Adam(self.steganalysis.detector.parameters(), lr=0.001)
        criterion = nn.BCELoss()
        
        losses = []
        accuracies = []
        
        self.steganalysis.detector.train()
        
        for epoch in range(epochs):
            epoch_loss = 0.0
            correct = 0
            total = 0
            
            for images, detection_labels, _, _, _ in tqdm(train_loader, desc=f"Epoch {epoch+1}/{epochs}"):
                images = images.to(self.device)
                detection_labels = detection_labels.to(self.device)
                
                optimizer.zero_grad()
                
                outputs = self.steganalysis.detector(images).squeeze()
                loss = criterion(outputs, detection_labels)
                
                loss.backward()
                optimizer.step()
                
                epoch_loss += loss.item()
                
                # Calculate accuracy
                predicted = (outputs > 0.5).float()
                total += detection_labels.size(0)
                correct += (predicted == detection_labels).sum().item()
            
            avg_loss = epoch_loss / len(train_loader)
            accuracy = correct / total
            
            losses.append(avg_loss)
            accuracies.append(accuracy)
            
            print(f"Epoch {epoch+1}: Loss = {avg_loss:.4f}, Accuracy = {accuracy:.4f}")
        
        self.training_history['detector_loss'].extend(losses)
        self.training_history['detector_accuracy'].extend(accuracies)
        
        return losses
    
    def train_capacity_estimator(self, train_loader: DataLoader, epochs: int = 20) -> List[float]:
        """Train the capacity estimator."""
        
        print("Training Capacity Estimator...")
        
        optimizer = optim.Adam(self.steganalysis.capacity_estimator.parameters(), lr=0.001)
        criterion = nn.MSELoss()
        
        losses = []
        maes = []
        
        self.steganalysis.capacity_estimator.train()
        
        for epoch in range(epochs):
            epoch_loss = 0.0
            epoch_mae = 0.0
            
            for images, _, capacity_labels, _, _ in tqdm(train_loader, desc=f"Epoch {epoch+1}/{epochs}"):
                images = images.to(self.device)
                capacity_labels = capacity_labels.to(self.device)
                
                optimizer.zero_grad()
                
                outputs = self.steganalysis.capacity_estimator(images).squeeze()
                loss = criterion(outputs, capacity_labels)
                
                loss.backward()
                optimizer.step()
                
                epoch_loss += loss.item()
                epoch_mae += torch.mean(torch.abs(outputs - capacity_labels)).item()
            
            avg_loss = epoch_loss / len(train_loader)
            avg_mae = epoch_mae / len(train_loader)
            
            losses.append(avg_loss)
            maes.append(avg_mae)
            
            print(f"Epoch {epoch+1}: Loss = {avg_loss:.4f}, MAE = {avg_mae:.4f}")
        
        self.training_history['capacity_loss'].extend(losses)
        self.training_history['capacity_mae'].extend(maes)
        
        return losses
    
    def train_type_classifier(self, train_loader: DataLoader, epochs: int = 20) -> List[float]:
        """Train the text type classifier."""
        
        print("Training Text Type Classifier...")
        
        optimizer = optim.Adam(self.steganalysis.type_classifier.parameters(), lr=0.001)
        criterion = nn.CrossEntropyLoss()
        
        losses = []
        accuracies = []
        
        self.steganalysis.type_classifier.train()
        
        for epoch in range(epochs):
            epoch_loss = 0.0
            correct = 0
            total = 0
            
            for images, _, _, type_labels, _ in tqdm(train_loader, desc=f"Epoch {epoch+1}/{epochs}"):
                images = images.to(self.device)
                type_labels = type_labels.to(self.device)
                
                optimizer.zero_grad()
                
                outputs = self.steganalysis.type_classifier(images)
                loss = criterion(outputs, type_labels)
                
                loss.backward()
                optimizer.step()
                
                epoch_loss += loss.item()
                
                # Calculate accuracy
                _, predicted = torch.max(outputs.data, 1)
                total += type_labels.size(0)
                correct += (predicted == type_labels).sum().item()
            
            avg_loss = epoch_loss / len(train_loader)
            accuracy = correct / total
            
            losses.append(avg_loss)
            accuracies.append(accuracy)
            
            print(f"Epoch {epoch+1}: Loss = {avg_loss:.4f}, Accuracy = {accuracy:.4f}")
        
        self.training_history['type_loss'].extend(losses)
        self.training_history['type_accuracy'].extend(accuracies)
        
        return losses
    
    def train_complete_system(self, num_samples: int = 2000, batch_size: int = 32, epochs: int = 20):
        """Train the complete steganalysis system."""
        
        print("🚀 Starting Complete Steganalysis Training")
        print("=" * 50)
        
        # Generate training data
        images, detection_labels, capacity_labels, type_labels, texts = self.generate_training_data(num_samples)
        
        # Create dataset and dataloader
        dataset = TensorDataset(images, detection_labels, capacity_labels, type_labels, 
                               torch.tensor([hash(t) for t in texts]))  # Placeholder for texts
        train_loader = DataLoader(dataset, batch_size=batch_size, shuffle=True)
        
        # Train each component
        print("\n🎯 Phase 1: Binary Text Detection")
        self.train_binary_detector(train_loader, epochs)
        
        print("\n📏 Phase 2: Capacity Estimation")
        self.train_capacity_estimator(train_loader, epochs)
        
        print("\n🔍 Phase 3: Text Type Classification")
        self.train_type_classifier(train_loader, epochs)
        
        # Save trained models
        save_dir = os.path.join('models', 'steganalysis')
        self.steganalysis.save_model_weights(save_dir)
        print(f"\n💾 Models saved to {save_dir}")
        
        # Plot training curves
        self.plot_training_curves()
        
        # Evaluate on test data
        self.evaluate_system(images[:100], detection_labels[:100], texts[:100])
        
        print("\n🎉 Steganalysis Training Completed!")
        return self.training_history
    
    def plot_training_curves(self):
        """Plot training curves for all models."""
        
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        fig.suptitle('Steganalysis Training Progress', fontsize=16)
        
        # Binary detector
        if self.training_history['detector_loss']:
            axes[0, 0].plot(self.training_history['detector_loss'])
            axes[0, 0].set_title('Binary Detector Loss')
            axes[0, 0].set_xlabel('Epoch')
            axes[0, 0].set_ylabel('Loss')
            axes[0, 0].grid(True)
            
            axes[1, 0].plot(self.training_history['detector_accuracy'])
            axes[1, 0].set_title('Binary Detector Accuracy')
            axes[1, 0].set_xlabel('Epoch')
            axes[1, 0].set_ylabel('Accuracy')
            axes[1, 0].grid(True)
        
        # Capacity estimator
        if self.training_history['capacity_loss']:
            axes[0, 1].plot(self.training_history['capacity_loss'])
            axes[0, 1].set_title('Capacity Estimator Loss')
            axes[0, 1].set_xlabel('Epoch')
            axes[0, 1].set_ylabel('Loss')
            axes[0, 1].grid(True)
            
            axes[1, 1].plot(self.training_history['capacity_mae'])
            axes[1, 1].set_title('Capacity Estimator MAE')
            axes[1, 1].set_xlabel('Epoch')
            axes[1, 1].set_ylabel('MAE')
            axes[1, 1].grid(True)
        
        # Type classifier
        if self.training_history['type_loss']:
            axes[0, 2].plot(self.training_history['type_loss'])
            axes[0, 2].set_title('Type Classifier Loss')
            axes[0, 2].set_xlabel('Epoch')
            axes[0, 2].set_ylabel('Loss')
            axes[0, 2].grid(True)
            
            axes[1, 2].plot(self.training_history['type_accuracy'])
            axes[1, 2].set_title('Type Classifier Accuracy')
            axes[1, 2].set_xlabel('Epoch')
            axes[1, 2].set_ylabel('Accuracy')
            axes[1, 2].grid(True)
        
        plt.tight_layout()
        plt.savefig('steganalysis_training_curves.png', dpi=300, bbox_inches='tight')
        plt.show()
        
        print("📊 Training curves saved as 'steganalysis_training_curves.png'")
    
    def evaluate_system(self, test_images: torch.Tensor, test_labels: torch.Tensor, test_texts: List[str]):
        """Evaluate the trained steganalysis system."""
        
        print("\n📈 Evaluating Steganalysis System")
        print("-" * 40)
        
        # Convert detection labels to boolean
        ground_truth = [bool(label) for label in test_labels.numpy()]
        
        # Run evaluation
        metrics = self.steganalysis.evaluate_performance(test_images, ground_truth, test_texts)
        
        print("Performance Metrics:")
        for metric, value in metrics.items():
            if isinstance(value, float):
                print(f"  {metric.replace('_', ' ').title()}: {value:.3f}")
            else:
                print(f"  {metric.replace('_', ' ').title()}: {value}")
        
        # Save evaluation results
        with open('steganalysis_evaluation.json', 'w') as f:
            json.dump(metrics, f, indent=2)
        
        print("💾 Evaluation results saved to 'steganalysis_evaluation.json'")


def main():
    """Main training function."""
    
    # Check device
    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    print(f"Using device: {device}")
    
    # Initialize trainer
    trainer = SteganalysisTrainer(device)
    
    # Train the complete system
    history = trainer.train_complete_system(
        num_samples=1000,  # Adjust based on your computational resources
        batch_size=32,
        epochs=15
    )
    
    print("\n✅ Steganalysis System Training Complete!")
    print("\nNext steps:")
    print("1. Test on real steganographic images")
    print("2. Fine-tune hyperparameters")
    print("3. Integrate with web interface")


if __name__ == "__main__":
    main()
